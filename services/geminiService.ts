import { GoogleGenAI } from "@google/genai";

const wait = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Client-side image resizing
// Balanced Mode: 512px (longest edge) / 0.7 quality
// 512px allows for sufficient detail for texture recognition (torn paper edges)
const resizeImage = (base64Str: string, maxDimension = 512): Promise<string> => {
  console.time('画像圧縮にかかった時間');
  return new Promise((resolve) => {
    const img = new Image();
    img.src = base64Str;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let width = img.width;
      let height = img.height;

      // Resize logic based on the longest edge
      if (width > height) {
        if (width > maxDimension) {
          height = Math.round((height * maxDimension) / width);
          width = maxDimension;
        }
      } else {
        if (height > maxDimension) {
          width = Math.round((width * maxDimension) / height);
          height = maxDimension;
        }
      }

      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx?.drawImage(img, 0, 0, width, height);
      
      // Compress to JPEG 0.7 for good texture detail
      const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
      console.timeEnd('画像圧縮にかかった時間');
      
      // Log size for debugging
      const sizeInBytes = (compressedDataUrl.length * 3) / 4;
      console.log(`圧縮後のデータサイズ（KB）: ${(sizeInBytes / 1024).toFixed(2)} KB`);
      
      resolve(compressedDataUrl);
    };
  });
};

export const generateCollage = async (imageBase64: string, stylePrompt: string): Promise<string> => {
  // The API key must be obtained exclusively from the environment variable process.env.API_KEY.
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

  // Resize image
  const optimizedBase64 = await resizeImage(imageBase64);
  
  // Remove data URL prefix if present for the API call
  const base64Data = optimizedBase64.split(',')[1];
  const mimeType = 'image/jpeg';

  // Base instruction for HIGH IMPACT ARTISTIC RECONSTRUCTION
  // Aggressively creative, bold, and transformative
  const basePrompt = `
    TRANSFORM this photo into a BOLD, EXPRESSIVE, HIGH-IMPACT COLLAGE ARTWORK.

    CRITICAL RULES FOR BOLDNESS:
    1. EXAGGERATE AND REIMAGINE: Do not be constrained by the original realism. Amplify dimensions, expressions, and colors.
    2. DYNAMIC COMPOSITION: Break the image apart! Use diagonal cuts, overlapping layers, and explosive arrangements. Avoid static, centered compositions.
    3. RAW MATERIALS: It must feel tactile. Use ripped posters, thick paint drips, crumpled paper, and mixed media textures.
    4. NO BORING FILTERS: This is a reconstruction, not a filter. The subject should be artistically reassembled.
    5. MAXIMALIST ENERGY: Fill the canvas. Use typography, abstract shapes, and contrasting textures to create visual energy.

    The goal is a MASTERPIECE that pops off the screen. Make it edgy, loud, and visually stunning.
  `;

  // Combine base prompt with specific style instructions
  const finalPrompt = `${basePrompt}\n\nSpecific Style Instructions:\n${stylePrompt}`;

  const makeRequest = async (retries = 3, delay = 1000): Promise<string> => {
    try {
      console.time('API通信（AI生成）にかかった時間');
      const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
          parts: [
            {
              inlineData: {
                data: base64Data,
                mimeType: mimeType,
              },
            },
            {
              text: finalPrompt,
            },
          ],
        },
      });
      console.timeEnd('API通信（AI生成）にかかった時間');

      // Extract the image from the response
      for (const part of response.candidates?.[0]?.content?.parts || []) {
        if (part.inlineData) {
          return `data:image/png;base64,${part.inlineData.data}`;
        }
      }

      throw new Error("No image generated by the model.");
    } catch (error: any) {
      // Retry on 429 (Too Many Requests) or 503 (Service Unavailable)
      if (retries > 0 && (error.status === 429 || error.status === 503 || error.message?.includes('429'))) {
        console.warn(`API Rate limited. Retrying in ${delay}ms...`);
        await wait(delay);
        return makeRequest(retries - 1, delay * 2);
      }
      console.error("Gemini API Error:", error);
      throw error;
    }
  };

  return makeRequest();
};